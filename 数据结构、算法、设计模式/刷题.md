

## 巧妙思路：

1. 异或去除偶数相同数字 
2. 摩尔投票
3. hash统计重复数目





## 刷题：

1. 汉明距离：两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。

   1.bin(x ^ y).count('1')

   2.布赖恩·克尼根算法（快速计算1的个数）

2. 只出现一次的数字：给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

   1.使用集合存储数字。

   2.使用哈希表存储每个数字和该数字出现的次数。

   3.使用集合存储数组中出现的所有数字，并计算数组中的元素之和。

   4.异或 **(异或运算满足交换律和结合律)**

3. 多数元素：给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

   方法一：哈希表

   方法二：排序

   方法四：分治

   方法五：Boyer-Moore 投票算法
   
4. 打家劫舍：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。未做

5. 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

   方法一：空间局部优化，类似计数排序

   方法二：空间最优，操作局部优化

6. 给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

   找到所有在 [1, n] 范围之间没有出现在数组中的数字。

   您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

   方法二：原地修改

7. 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

   解答：https://leetcode-cn.com/problems/merge-two-sorted-lists/

8. **给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。**

   https://leetcode-cn.com/problems/move-zeroes/solution/

   9. 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

      方法一：暴力枚举

      **方法二：哈希表** （C呢、C++呢 map？）

   10. 给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）
   
       方法一：迭代法实现子集枚举
   
       方法二：递归法实现子集枚举  (回溯算法？)
       
       11. 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。
       
       12. 
       
       13. 数字 *n* 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
       
           方法一：暴力法，递归生成树，自顶向下，校验是否合法  O(2^2n  * n校验合法)，空间复杂度：O(n)
       
           方法二：回溯法，时间复杂度：O(\dfrac{4^n}{\sqrt{n}})*O*(*n*4*n*)？，空间复杂度：O(n)*O*(*n*)
       
           方法三：按括号序列的长度递归
       
           
       
           14. 中序遍历
       
               方法二：stack 迭代
       
               方法三：Morris 中序遍历
       
           15. 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
       
               回溯？剪枝
       
           16.给定一个二叉树，[原地](https://baike.baidu.com/item/原地算法/8010757)将它展开为一个单链表。
           
           方法二：前序遍历和展开同步进行
           
           方法三：寻找前驱节点？
           
           17.[K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
           
           18.[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
           
           给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。
           
           方法一：动态规划 TODO?
           
           方法二：中心扩展算法
           
           19.设计一个支持在*平均* 时间复杂度 **O(1)** 下，执行以下操作的数据结构(insert/remove/getRandom)
           
           20.有序数组/链表去重
           
           21.给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
           
           22.给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
           
           






### 基础算法：

1. ##### 十大排序算法



2. ##### 七大查找算法

   1) 静态查找和动态查找：动态表指查找表中有删除和插入操作的表

   2) 无序查找和有序查找：无序查找有如  遍历查找



##### 1. 数据结构存储：

**「结构基础」：数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）**。

「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。

「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵**判断连通性迅速**，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。

「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。

「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树（叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部），用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为**不一定是完全二叉树，所以不适合用数组存储**。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。



**数组**由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

**链表**因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。



**2.数据结构基本操作**

对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改

各种数据结构的遍历 + 访问无非两种形式：线性的和非线性



2.1 数组遍历框架

```
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        // 迭代访问 arr[i]
    }
}
```

2.2 链表遍历框架

```
/* 基本的单链表节点 */
class ListNode {
    int val;
    ListNode next;
}

1. void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {
        // 迭代访问 p.val
    }
}

2. void traverse(ListNode head) {
    // 递归访问 head.val
    traverse(head.next);
}
```

2.3 二叉树遍历框架

```
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    traverse(root.left);
    traverse(root.right);
}
```

2.4 N 叉树的遍历

```
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}

void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child);
}
```



#### 3. 线性表

1. 翻转链表：迭代实现；递归实现。
2. 翻转k组链表：1. 翻转k个链表（全翻转head->null, 部分翻转head->b）
3. 最长公共子串: TODO?
4. 最长回文子串: 1.动态规划 2.中心扩展



5.二分查找

6.二分查找左边界、右边界



快慢指针

7.判定链表是否有环

8.链表有环，返回起始位置

9.寻找链表中点（长度为偶数则停在中点靠右）

10.寻找链表倒数k的位置

11.有序数组去重

12.移除数组内为val的元素

13.移动零



左右指针

1.二分查找

2.有序数组找到 两数之和（只要数组有序，就可以想到双指针）

3.反转数组

4.滑动窗口算法: TODO?



1. O(1) (insert/remove/getRandom)

   

1.反转二叉树：递归解法；TODO 迭代？

2.connect二叉树：递归解法；TODO迭代

3.二叉树展开为链表：递归；/todo迭代

4.构造最大二叉树：递归





动态规划

1. 柠檬 5、10、20美元

2. 数组内最大连续子数组

   股票  一次买卖 最大值：规划；单调栈？

4. #### [使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

5. #### [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

6. 



单调栈