

## 巧妙思路：

1. 异或去除偶数相同数字 
2. 摩尔投票
3. hash统计重复数目





## 刷题：

1. 汉明距离：两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。

   1.bin(x ^ y).count('1')

   2.布赖恩·克尼根算法（快速计算1的个数）

2. 只出现一次的数字：给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

   1.使用集合存储数字。

   2.使用哈希表存储每个数字和该数字出现的次数。

   3.使用集合存储数组中出现的所有数字，并计算数组中的元素之和。

   4.异或 **(异或运算满足交换律和结合律)**

3. 多数元素：给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

   方法一：哈希表

   方法二：排序

   方法四：分治

   方法五：Boyer-Moore 投票算法
   
4. 打家劫舍：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。未做

5. 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

   方法一：空间局部优化，类似计数排序

   方法二：空间最优，操作局部优化

6. 给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

   找到所有在 [1, n] 范围之间没有出现在数组中的数字。

   您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

   方法二：原地修改

7. 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

   解答：https://leetcode-cn.com/problems/merge-two-sorted-lists/

8. **给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。**

   https://leetcode-cn.com/problems/move-zeroes/solution/

   9. 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

      方法一：暴力枚举

      **方法二：哈希表** （C呢、C++呢 map？）

   10. 给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）
   
       方法一：迭代法实现子集枚举
   
       方法二：递归法实现子集枚举  (回溯算法？)
       
       11. 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。
       
           






### 基础算法：

1. ##### 十大排序算法



2. ##### 七大查找算法

   1) 静态查找和动态查找：动态表指查找表中有删除和插入操作的表

   2) 无序查找和有序查找：无序查找有如  遍历查找



回溯法：

