## previous：

#### 1. 算法分析

- 近似表示，算法分析中常用的近似函数
- 2-sum及3-sum更为快捷的算法
- 倍率定理
- 近似过程可能存在的偏差点



#### 2. 排序算法

1. 术语

   排序class模板：sort方法，less、exchange方法，show、isSort方法

   java：实现comparable，compareTo()方法，新class inmplements comparable

2. 选择排序

   思想：不断选择剩余列表内最大 or 最小的

   时间复杂度及空间复杂度：最好和最坏的情况都是  n*(n-1)/2次比较 + n次交换

   1. 时间复杂度跟输入无关，最差和最好都一样 2.数据移动次数是最少的（特点）

3. 插入排序

   思想：将一个item插入已经有序的列表里

   时间复杂度：最好的情况 n次比较 + n次插入(0次交换)，最差的情况 n*(n-1)/2次比较 + n次插入
   
   已经有序或者接近有序时效率最高（特点）
   
4. 希尔排序

   思想：h等分，h有序数组

   特点？

5. 归并排序

   原地归并

   思想：

6. 快排





#### 3. 查找

1. ###### 关键点：
   1. 查找的应用：通过 key 找到 val

   2. 关键api：

      put（insert）、get（search）、del、contains、isEmpty、size、keys

      floor（向下取整（key））、ceiling（向上取整（key））

   3. key不能重复：插入已有key，覆盖原有val

   4. 不能有空key和空val

      

2. ###### 无序列表

   遍历

3. ###### 有序列表



#### 4. 图算法

1. 关键点：

   图 由 vertex 和 edge 构成

   图 用来解决什么问题：两个点之间的最短距离 shorterst-path problem  。（实际应用）

   图 的描述：python可以用字典(key:val数组)；c++呢？邻接表、邻接矩阵

- ​	有向图和无向图

- ​	加权与否

  

1. BFS

   解决两类问题：1.从A出发，是否可达B；2.从A出发，到达B的最短路径。

   用于 无权重图 最短路径

   实现：python可以使用queue

   

2. DFS

   解决 迷宫 问题

   实现：python可以使用stack

   

3. Dijkstra

   用于 有向无环 图（有向才可能有环），加权。该场景下最短路径。

   存在 负边权 无法使用。负边权 可以采用 Bellman-Ford算法、Floyd Warshall's algorithm

   思路？

   

4.  Bellman-Ford算法

   不可以出现负权环

   松弛函数：作用，就是判断是否经过某个顶点，或者说经过某条边，可以缩短起点到终点的路径权值。

   **Bellman-Ford算法的用途**

   - 从A出发，是否存在到达各个节点的路经（有计算出值表示可以到达）；

   - 从A出发，到达各个节点最短路经（时间最少、或者路经最少等）;

   - 图中是否存在负环路（权重之和为负数）;

     

5. 启发式A star 算法

   地图 最短路径

   实现思路？

   

6. 拓扑排序

   定义：拓扑排序其实是一个线性排序。 若图中存在一条有向边从*u*指向*v*，则在拓扑排序中*u*一定出现在*v*前面

   实现思路？

   

#### 5. 贪婪算法

​	每步都采取最优的做法 ，局部最优。寻找大致解决问题的算法，次优解。

​	排课问题；背包问题












